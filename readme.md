Short Description of Logic Implemented in the Project

This project includes several small but meaningful programs that show different ways of solving problems and using computational methods.
Each program has a specific purpose, such as doing math, managing data, working with strings, checking if expressions are valid, and recognizing patterns. Even though each program is different, they all follow the same general steps: getting input from the user or the system, using clear rules to process that input, keeping data organized as needed, and giving the correct result. These programs help explain key programming ideas like object-oriented design, recursive solutions, checking expressions using stacks, using hash tables, handling files, and dynamic programming.

The calculator program is a console-based interactive tool that lets the user perform four basic math operations: adding, subtracting, multiplying, and dividing.
The user is shown prompts to enter numbers and choose which operation to use. The program uses a Scanner to get input safely and checks if the input is a number to avoid errors. Each math operation is handled by a separate method, making it easier to manage and update. A list keeps track of all the results from each calculation, so the user can see the history. The calculator continues running until the user decides to exit using a menu. It also handles division by zero to prevent crashes. This program shows good input handling, organized code, and keeping track of data during the session.

The Library Management System simulates a small library that keeps track of books using a list of Book objects.
Each book has an ID, a title, an author's name, and a status showing if it’s borrowed. This setup makes each book a separate unit with both data and actions. The system allows users to add new books, search for books by title or author, borrow books, and return them. Before adding a new book, the system checks if the ID already exists to stop duplicates. Searches compare the user's input to the title or author of the books. When a book is borrowed or returned, its status is updated so that no one can borrow a book that’s already checked out. The user interacts with a menu that keeps asking for choices and performs the selected action. This program shows object-oriented programming, dynamic lists, input checks, and how objects can change their state.

The URL shortener focuses on the backend logic without any user interface.
It only uses two functions: one to generate a short code from a long URL and another to redirect to the original URL using the code. The shorten function creates a unique six-character code using letters and numbers. Before creating a new code, it checks if the same URL was already shortened to make sure the same code is always used. The system stores these mappings in a local JSON file to keep the data even after the program ends. The redirect function looks up the code to find the original URL or returns nothing if it’s not found. This program demonstrates creating random codes, saving data in files, and using a dictionary to map keys to values, which are common in real services like Bitly.

The Word Frequency program looks at a text and counts how often each word appears.
It starts by making all text lowercase and removing punctuation to keep comparisons consistent. Then, it splits the text into individual words based on spaces. A map keeps track of each word as a key and its count as the value. Every time a word is found, the map either adds it with a count of one or increases its existing count. Finally, the words are sorted by how often they appear and the results are shown to the user. This program shows how to process strings, use hash tables, sort data, and do basic text analysis.

The Balanced Brackets program checks if a string of brackets is properly matched and nested.
It uses a stack, a common data structure. As it goes through each character, opening brackets like (, {, or [ are pushed onto the stack. When a closing bracket is found, the program checks if the most recent opening bracket matches the closing one. If it doesn’t or if there’s nothing on the stack when a closing bracket is found, the string is unbalanced. After the entire string is processed, the stack must be empty for the brackets to be balanced. This program shows how to use a stack, process data in a linear way, and check if expressions are valid.

The Longest Increasing Subsequence (LIS) program finds the length of the longest sequence in an array where each number is higher than the one before it.
The program uses a recursive method to find the LIS ending at each position by checking all earlier positions. While this method isn’t the most efficient, it clearly shows how to use recursion and build solutions from smaller parts. More efficient approaches like dynamic programming or binary search exist, but the recursive method is useful for explaining the idea of breaking problems into smaller solutions.